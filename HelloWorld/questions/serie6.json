[
  {
    "question": "1. Que retourne Promise.resolve(42) ?",
    "options": [
      "Une erreur",
      "Une promesse rejetée",
      "Une promesse déjà résolue avec la valeur 42",
      "Une promesse en attente"
    ],
    "answerIndex": 2,
    "explications": "Promise.resolve(42) crée une promesse qui est immédiatement résolue avec la valeur 42. Cela permet d'encapsuler une valeur dans une promesse pour l'utiliser dans des chaînes then(). \n Exemple:\n const p = Promise.resolve(42); \n p.then(value => console.log(value)); // Affiche : 42"
  }
,
  {
    "question": "2 - Que fait le mot-clé await ?",
    "options": [
      "Termine une fonction",
      "Met la fonction en pause jusqu’à ce qu’une promesse soit résolue",
      "Crée une promesse",
      "Répète une fonction"
    ],
    "answerIndex": 1,
    "explication": "await est utilisé à l'intérieur d'une fonction async pour attendre le résultat d'une promesse. Cela permet d’écrire du code asynchrone de manière plus lisible, comme du code synchrone. \n Exemple:\n async function getUser() { \n const response = await fetch(\"https://api.example.com/user\"); \n const data = await response.json(); \n console.log(data); \n }"
  },
  {
    "question": "3 - Quelle est la sortie de [...\"abc\"] ?",
    "options": [
      "\"abc\"",
      "[\"a\", \"abc\"]",
      "[\"a\", \"b\", \"c\"]",
      "[\"abc\"]"
    ],
    "answerIndex": 2,
    "explication": "L'opérateur de décomposition (...) transforme la chaîne \"abc\" en un tableau de caractères.. \n Exemple:\n const letters = [...\"abc\"]; \n  console.log(letters); // [\"a\", \"b\", \"c\"]"
    },
    {
    "question": "4 -  Que fait Object.freeze(obj) ?",
    "options": [
      "Supprime l’objet",
      "Rend l’objet temporairement inaccessible",
      "Supprime ses méthodes",
      "Rend l’objet immuable (impossible à modifier)"
    ],
    "answerIndex": 3,
    "explication": " Object.freeze() empêche toute modification : on ne peut ni ajouter, ni modifier, ni supprimer les propriétés de l’objet. \n Exemple:\n const user = Object.freeze({ name: \"Alice\" }); \n user.name = \"Bob\"; \n // Ne fonctionne pas \n console.log(user.name); // \"Alice\""
  },
  {
    "question": "5 - Comment tester si une variable est un tableau ?",
    "options": [
      "typeof var === \"array\"",
      "Array.isArray(var)",
      "var instanceof Object",
      "typeof var === \"object\""
    ],
    "answerIndex": 1,
    "explication": "Array.isArray() est la méthode la plus fiable pour savoir si une variable est bien un tableau, car typeof renvoie \"object\" pour les tableaux aussi.\n Exemple:\n console.log(Array.isArray([1, 2, 3])); // true \n console.log(Array.isArray(\"hello\"));  // false"
  },
  {
    "question": "6 -À quoi sert \"??\" (opérateur de coalescence nulle) ? ",
    "options": [
      "Remplace tous les false",
      "Supprime les undefined",
      "Donne une valeur par défaut si la première est null ou undefined",
      "Teste la nullité stricte"
    ],
    "answerIndex": 2,
    "explication": "?? vérifie si une valeur est nul ou undefined, et retourne une valeur de repli si c’est le cas. Contrairement à ||, il ne tient pas compte des 0, false, ou \"\". \n Exemple:\n const name = null; \n const username = name ?? \"Invité\"; // \"Invité\""
  },
  {
    "question": "7 - Que renvoie [1, 2, 3].map(parseInt) ?",
    "options": [
      "[1, NaN, NaN]",
      "[1, 2, 3]",
      "[1, 2, NaN]",
      "Erreur"
    ],
    "answerIndex": 0,
    "explication": "map() passe deux arguments à parseInt : la valeur et l’index. parseInt(\"2\", 1) est invalide, donc renvoie NaN. \n Exemple: \n [1, 2, 3].map((val, index) => parseInt(val, index)); \n // [1, NaN, NaN]"
  },
  {
    "question": "8 - Quelle est la différence entre == et === ?",
    "options": [
      "== est plus rapide",
      "Aucune différence",
      "=== permet la conversion automatique",
      "=== compare aussi les types"
    ],
    "answerIndex": 3,
    "explication": "== fait une conversion de type implicite, alors que === exige que valeurs et types soient identiques. \n Exemple: \n console.log(\"5\" == 5);  // true (conversion automatique) \n console.log(\"5\" === 5); // false (types différents)"
  },
  {
    "question": "9 - Que fait Object.assign() ? ",
    "options": [
      "Vide l’objet",
      "Supprime des propriétés",
      "Copie les propriétés d’un ou plusieurs objets dans un autre",
      "Restaure l’état d’un objet"
    ],
    "answerIndex": 2,
    "explication": "Object.assign(dest, source) copie les propriétés de source vers dest. Cela crée une copie superficielle (shallow copy).\n Exemple: \n const a = { x: 1 }; \n const b = { y: 2 }; \n const result = Object.assign({}, a, b); \n console.log(result); // { x: 1, y: 2 }\n "
  },
  {
    "question": "10 - Que fait delete obj.prop ?",
    "options": [
      "Supprime une propriété de l’objet",
      "Vide tout l’objet",
      "Gèle l’objet",
      "Masque la propriété"
    ],
    "answerIndex": 0,
    "explication": "delete permet de retirer une propriété spécifique d’un objet, mais cela ne fonctionne que si la propriété n’est pas verrouillée (configurable: false). \n Exemple: \n const user = { name: \"Alice\" }; \n delete user.name; \n console.log(user); // {}"
  },
  {
    "question": "11 -Que fait JSON.stringify() ?",
    "options": [
      "Parse un JSON",
      "Exécute une promesse",
      "Convertit un objet en chaîne JSON",
      "Compresse un objet"

    ],
    "answerIndex": 2,
    "explication": "Cette méthode transforme un objet JavaScript en chaîne JSON, utile pour le stockage ou l’envoi via une API. \n Exemple: \n const user = { \n name: \"Alice\", age: 30\n };\n console.log(JSON.stringify(user)); \n // '{\"name\":\"Alice\",\"age\":30}'"
  },
  {
    "question": "12 - Quelle est la sortie de typeof NaN ?",
    "options": [
      "number",
      "NaN",
      "undefined",
      "number"
      
    ],
    "answerIndex": 3,
    "explication": "NaN (Not a Number) est de type number, même si la valeur représente une erreur numérique. \n Exemple:\n  console.log(typeof NaN); // \"number\""
  },
  {
    "question": "13 - Que retourne typeof null ?",
    "options": [
      "object",
      "null",
      "undefined",
      "NaN"
    ],
    "answerIndex": 0,
    "explication": "C’est une bizarrerie historique de JavaScript. typeof null retourne \"object\" à cause d’un bug jamais corrigé. \n Exemple:\n  console.log(typeof null); // \"object\""
  },
  {
    "question": "14 - Que fait la méthode .bind() ? ",
    "options": [
      "L’appelle directement",
      "Remplace la fonction",
      "Fixe le this d'une fonction",
      "Exécute plusieurs fonctions"
    ],
    "answerIndex": 2,
    "explication": ".bind() retourne une nouvelle fonction avec un this prédéfini, utile pour garder le contexte. \n Exemple: \n const person = { name: \"Alice\" };\n function greet() { \n console.log(\"Bonjour\" + this.name); \n } \n const greetAlice = greet.bind(person); \n greetAlice(); // Bonjour Alice"
  },
  {
    "question": "15 - Que retourne [1, 2, 3].reduce((a, b) => a + b, 0) ?",
    "options": [
      "62",
      "123",
      "6",
      "[1, 2, 3]"
    ],
    "answerIndex": 2,
    "explication": "reduce() additionne ici tous les éléments du tableau en partant de 0. \n Exemple: \n const total = [1, 2, 3].reduce((acc, val) => acc + val, 0); \n console.log(total); // 6"
  },
  {
    "question": "16 - Que fait Object.freeze() ?",
    "options": [
      "Supprime les propriétés d’un objet",
      "Rend l’objet immuable",
      "Clone l’objet",
      "Vide l’objet"
    ],
    "answerIndex": 1,
    "explication": "Object.freeze() empêche toute modification future de l’objet (ajout, suppression, modification de propriétés). \n Exemple: \n  const user = Object.freeze({ name: \"Alice\" }); \n user.name = \"Bob\"; \n console.log(user.name); // \"Alice\""
  },
  {
    "question": "17 - Quelle est la sortie de ce code ? `console.log([...'hello'])`",
    "options": ["['hello']", "['h', 'e', 'l', 'l', 'o']", "['he', 'll', 'o']", "Erreur"],
    "answerIndex": 1,
    "explication": "L'opérateur de décomposition `...` décompose la chaîne de caractères en caractères individuels. Résultat : ['h', 'e', 'l', 'l', 'o']"
  },
  {
    "question": "18 - Que fait setTimeout(fn, 0) ?",
    "options": [
      "Appelle la fonction immédiatement",
      "Ignore la fonction",
      "Exécute fn après la pile d’exécution",
      "Bloque le script"
    ],
    "answerIndex": 2,
    "explication": "Même avec 0 ms, setTimeout place la fonction dans la file d’attente, elle s'exécutera après les scripts synchrones. \n Exemple: \n setTimeout(() => console.log(\"A\"), 0); \n console.log(\"B\"); \n // Affiche : B puis A"
  },
  {
    "question": "19 - À quoi sert le mot-clé this ?",
    "options": [ 
      "À accéder à la variable globale",
      "À référencer l’objet courant",
      "À appeler une classe",
      "À créer une fonction"
    ],
    "answerIndex": 1,
    "explication": "this représente le contexte d’exécution courant, souvent l’objet qui appelle la méthode. \n Exemple: \n const car = { \n brand: \"Toyota\", \n getBrand() { return this.brand; } \n }; \n console.log(car.getBrand()); // Toyota"
  },
  {
    "question": "20 - Quelle méthode permet de copier un tableau sans le modifier ?",
    "options": [
      ".map()",
      ".filter()",
      ".reduce()",
      ".slice()"
    ],
    "answerIndex": 3,
    "explication": ".slice() sans argument retourne une copie du tableau d'origine. \n Exemple: \n const original = [1, 2, 3]; \n const copy = original.slice(); \n  console.log(copy); // [1, 2, 3]"
  },
   {
    "question": "21 - Que fait la méthode Array.prototype.flat() ?",
    "options": [
      "Elle trie un tableau",
      "Elle fusionne deux tableaux",
      "Elle aplatit les tableaux imbriqués",
      "Elle supprime les doublons"
    ],
    "answerIndex": 2,
    "explication": "flat() aplatit un tableau de tableaux imbriqués en un seul niveau. \nExemple:\nconst arr = [1, [2, [3, 4]]];\nconsole.log(arr.flat(2)); // [1, 2, 3, 4]"
  },
  {
    "question": "22 - Que retourne Array.from('123') ?",
    "options": [
      "[1, 2, 3]",
      "['123']",
      "['1', '2', '3']",
      "[123]"
    ],
    "answerIndex": 2,
    "explication": "Array.from() transforme une chaîne ou un objet itérable en tableau d’éléments. \n Exemple:\n console.log(Array.from('123')); // ['1', '2', '3']"
  },
  {
    "question": "23 - Que fait une closure en JavaScript ?",
    "options": [
      "Elle crée une promesse",
      "Elle protège des données en les encapsulant",
      "Elle exécute une fonction immédiatement",
      "Elle lie une fonction à un événement"
    ],
    "answerIndex": 1,
    "explication": "Une closure permet à une fonction d’accéder à des variables définies dans une portée supérieure même après l’exécution de cette dernière. \nExemple:\nfunction outer() {\n let count = 0;\n return function() { \n count++; \n return count;\n }\n}\n const counter = outer();\n console.log(counter()); // 1"
  },
  {
    "question": "24 - Que fait le mot-clé yield dans une fonction génératrice ?",
    "options": [
      "Il retourne une valeur finale",
      "Il interrompt définitivement la fonction",
      "Il génère une erreur",
      "Il suspend l’exécution et retourne une valeur temporaire"
    ],
    "answerIndex": 3,
    "explication": "Le mot-clé yield suspend temporairement l’exécution d’une fonction génératrice, qui peut être reprise plus tard. \nExemple:\nfunction* gen() {\n  yield 1;\n  yield 2;\n}\nconst g = gen();\nconsole.log(g.next().value); // 1"
  },
  {
    "question": "25 - Comment créer un objet sans prototype ?",
    "options": [
      "Object.empty()",
      "Object.create(Object.prototype)",
      "Object.create(null)",
      "{}",
      "new Object()"
    ],
    "answerIndex": 2,
    "explication": "Object.create(null) crée un objet sans héritage ni prototype. \nExemple:\nconst obj = Object.create(null);\nconsole.log(obj.toString); // undefined"
  },
  {
    "question": "26 - Que fait la méthode Object.entries() ?",
    "options": [
      "Elle retourne les noms des méthodes",
      "Elle retourne un tableau de clés",
      "Elle retourne un tableau de valeurs",
      "Elle retourne un tableau de paires [clé, valeur]"
    ],
    "answerIndex": 3,
    "explication": "Object.entries() transforme un objet en tableau de paires [clé, valeur]. \nExemple:\nconst user = {name: 'Alice', age: 30};\nconsole.log(Object.entries(user)); // [['name', 'Alice'], ['age', 30]]"
  },
  {
    "question": "27 - Que retourne [1, 2, 3].find(x => x > 1) ?",
    "options": [
      "[2, 3]",
      "true",
      "2",
      "undefined"
    ],
    "answerIndex": 2,
    "explication": "find() retourne le premier élément qui satisfait la condition. \nExemple:\nconst result = [1, 2, 3].find(x => x > 1);\nconsole.log(result); // 2"
  },
  {
    "question": "28 - Quelle méthode permet de vérifier si un tableau contient une valeur ?",
    "options": [
      "includes()",
      "has()",
      "contains()",
      "exist()"
    ],
    "answerIndex": 0,
    "explication": "includes() vérifie si un tableau contient une certaine valeur. \nExemple:\nconst fruits = ['pomme', 'banane'];\nconsole.log(fruits.includes('banane')); // true"
  },
  {
    "question": "29 - Comment convertir une chaîne en nombre ?",
    "options": [
      "parseNumber()",
      "Number()",
      "toInt()",
      "float()"
    ],
    "answerIndex": 1,
    "explication": "Number() convertit une chaîne en nombre si possible. \nExemple:\nconsole.log(Number('42')); // 42"
  },
  {
    "question": "30 - Que fait Promise.all() ?",
    "options": [
      "Elle résout la première promesse",
      "Elle enchaîne des promesses",
      "Elle arrête dès qu’une promesse échoue",
      "Elle attend que toutes les promesses soient résolues"
    ],
    "answerIndex": 3,
    "explication": "Promise.all() exécute plusieurs promesses en parallèle et retourne leurs résultats une fois toutes résolues. \nExemple:\nPromise.all([Promise.resolve(1), Promise.resolve(2)]).then(console.log); // [1, 2]"
  },
  {
    "question": "31 - Quelle est la différence entre var, let et const ?",
    "options": [
      "Aucune",
      "const peut être modifié",
      "let et const sont à portée de bloc, var à portée de fonction",
      "var est toujours préférable"
    ],
    "answerIndex": 2,
    "explication": "let et const ont une portée de bloc ({}), contrairement à var qui a une portée de fonction. const ne permet pas de réassignation. \nExemple : \n if (true) { \n blet x = 5; \n} \nconsole.log(x); // Erreur car x n'existe qu'à l’intérieur du bloc."
  },
  {
    "question": "32 - Quelle est la sortie de '5' + 3 ?",
    "options": [
      "8",
      "53",
      "Erreur",
      "NaN"
    ],
    "answerIndex": 1,
    "explication": "L'opérateur + effectue une **concaténation** si l’un des opérandes est une chaîne. \nExemple : \nconsole.log('5' + 3); // '53'"
  },
  {
    "question": "33 - Que fait la méthode Array.prototype.find() ?",
    "options": [
      "Retourne tous les éléments qui correspondent",
      "Retourne l'index de l'élément",
      "Retourne le premier élément qui satisfait une condition",
      "Trie le tableau"
    ],
    "answerIndex": 2,
    "explication": "find() retourne le **premier** élément du tableau qui satisfait la condition passée. \nExemple : \nconst nums = [1, 4, 6]; \nconst found = nums.find(n => n > 4); \nconsole.log(found); // 6"
  },
  {
    "question": "34 - Que fait une closure (fermeture) en JavaScript ?",
    "options": [
      "Permet à une fonction d’accéder à des variables d’un scope parent",
      "Rend les variables globales",
      "Efface les variables après exécution",
      "Interrompt l'exécution"
    ],
    "answerIndex": 0,
    "explication": "Une closure permet à une fonction imbriquée de **retenir l'accès aux variables** de sa portée parente même après la fin de cette dernière. \nExemple : \n function outer() { \n let x = 10;\n return function() { \nreturn x; \n};\n } \nconst getX = outer(); \n console.log(getX()); // 10"
  },
  {
    "question": "35 - Quelle est la sortie de [...'abc'] ?",
    "options": [
      "['abc']",
      "[...'abc']",
      "['a', 'b', 'c']",
      "Erreur"
    ],
    "answerIndex": 2,
    "explication": "L'opérateur de décomposition (...) transforme la chaîne en tableau de caractères. \nExemple : \nconsole.log([...\"abc\"]); // ['a', 'b', 'c']"
  },
  {
    "question": "36 - Que fait `Promise.all()` ?",
    "options": [
      "Attend la première promesse résolue",
      "Rejette si une promesse est rejetée",
      "Exécute les promesses de manière séquentielle",
      "Résout dès que toutes sont rejetées"
    ],
    "answerIndex": 1,
    "explication": "`Promise.all()` prend un tableau de promesses et retourne une seule promesse **résolue quand toutes le sont**, ou **rejetée si une échoue**. \n Exemple : \n Promise.all([Promise.resolve(1), Promise.resolve(2)]).then(console.log); // [1, 2]"
  },
  {
    "question": "37 - Quelle méthode convertit un nombre en chaîne ?",
    "options": [
      "toString()",
      "parseInt()",
      "Number()",
      "Stringify()"
    ],
    "answerIndex": 0,
    "explication": "`toString()` convertit un nombre en chaîne. \n Exemple : \n let n = 42; \n console.log(n.toString()); // '42'"
  },
  {
    "question": "38 - Que fait `Array.from()` ?",
    "options": [
      "Crée une chaîne depuis un tableau",
      "Copie un objet",
      "Crée un tableau à partir d’un objet itérable",
      "Transforme un tableau en objet"
    ],
    "answerIndex": 2,
    "explication": "`Array.from()` transforme un objet **itérable** (ex : chaîne, arguments, Set) en **tableau**. \nExemple : \nconsole.log(Array.from('123')); // ['1', '2', '3']"
  },
  {
    "question": "39 - Que retourne une fonction sans return explicite ?",
    "options": [
      "undefined",
      "null",
      "false",
      "0"
    ],
    "answerIndex": 0,
    "explication": "Si une fonction n’a pas de `return`, elle retourne `undefined` par défaut. \nExemple : \nfunction sayHi() { \n console.log('Hi'); \n } \nconsole.log(sayHi()); // undefined"
  },
  {
    "question": "40 - Que fait la méthode .includes() sur un tableau ?",
    "options": [
      "Ajoute un élément",
      "Supprime un élément",
      "Trie le tableau",
      "Vérifie si un élément existe"
    ],
    "answerIndex": 3,
    "explication": "`.includes()` vérifie si un tableau **contient** une valeur. \nExemple : \nconst fruits = ['apple', 'banana']; \nconsole.log(fruits.includes('banana')); // true"
  },
  {
    "question": "41- Quel est l'effet du mot-clé `async` devant une fonction ?",
    "options": ["Elle exécute le code en parallèle", "Elle retourne toujours une Promise", "Elle empêche les erreurs", "Elle rend la fonction plus rapide"],
    "answerIndex": 1,
    "explication": "Une fonction `async` retourne toujours une **Promise**, même si vous retournez une valeur simple. Cela permet l’utilisation de `await` à l’intérieur."
  },
 {
    "question": "42 - Quelle est la sortie de ce code : `console.log(0.1 + 0.2 === 0.3)` ?",
    "options": ["true", "false", "undefined", "NaN"],
    "answerIndex": 1,
    "explication": "En raison des imprécisions de l'arithmétique en virgule flottante en JavaScript, `0.1 + 0.2` donne 0.30000000000000004. Donc l'expression retourne `false`."
  },
 {
    "question": "43 - Que fait le mot-clé `yield` dans une fonction génératrice ?",
    "options": ["Il arrête complètement la fonction", "Il crée une boucle", "Il appelle une fonction interne", "Il retourne une valeur temporaire et peut reprendre plus tard"],
    "answerIndex": 3,
    "explication": "`yield` est utilisé dans les **fonctions génératrices** pour produire une valeur temporaire. L'exécution peut reprendre ensuite avec `.next()`.\nEx :\nfunction* gen() {\n  yield 1;\n  yield 2;\n}\nconst g = gen();\nconsole.log(g.next().value); // 1"
  },
   {
    "question": "44 - À quoi sert `Object.defineProperty()` ?",
    "options": ["Définir une propriété avec contrôle fin (writable, enumerable...)","Créer un objet",  "Supprimer une propriété", "Cloner un objet"],
    "answerIndex": 0,
    "explication": "`Object.defineProperty()` permet de créer ou modifier une propriété avec des options avancées comme `writable`, `enumerable`, et `configurable`.\nExemple :\nconst obj = {};\nObject.defineProperty(obj, 'name', {\n  value: 'Alice',\n  writable: false\n});"
  },
  {
    "question": "45 - Quelle est la différence entre `call()` et `apply()` ?",
    "options": [
      "`call()` prend un tableau d’arguments, `apply()` les sépare",
      "`call()` est asynchrone, `apply()` est synchrone",
      "`call()` et `apply()` font la même chose mais avec une syntaxe différente",
      "`apply()` est déprécié"
    ],
    "answerIndex": 2,
    "explication": "`call()` et `apply()` appellent une fonction en changeant son `this`, mais `call()` prend les arguments un à un, tandis que `apply()` les prend sous forme de tableau.\nExemple :\n js\nfunction greet(msg) { \n console.log(msg + ', ' + this.name);\n } \n const user = { name: 'Sara' }; \n greet.call(user, 'Hello'); \n greet.apply(user, ['Hi']);\n "
  },
  {
    "question": "46 - Que fait le mot-clé `await` dans une fonction async ?",
    "options": [
      "Met en pause l'exécution de la fonction jusqu’à la fin du script",
      "Rejette automatiquement une promesse",
      "Attends la résolution d’une promesse avant de continuer",
      "Transforme une fonction en promesse"
    ],
    "answerIndex": 2,
    "explication": "`await` suspend l’exécution de la fonction `async` jusqu’à ce que la promesse soit résolue ou rejetée.\nExemple :\n async function fetchData() {\n const data = await fetch('/api');\n console.log(data);\n}\n"
  },
  {
    "question": "47 - Que permet setTimeout(fn, 0) ?",
    "options": [
      "Appelle immédiatement la fonction",
      "Bloque le thread",
      "Exécute la fonction de façon synchrone",
      "Ajoute la fonction à la file d'attente d'exécution"
    ],
    "answerIndex": 3,
    "explication": "`setTimeout(fn, 0)` n'exécute pas immédiatement la fonction, mais la place à la fin de la file d'attente. \nExemple : \nsetTimeout(() => console.log('Hello'), 0); \nconsole.log('World'); // Affiche 'World' puis 'Hello'"
  },
  {
    "question": "48 - Que fait Object.assign() ?",
    "options": [
      "Crée un tableau",
      "Ajoute un élément à un objet",
      "Fusionne des objets",
      "Crée une classe"
    ],
    "answerIndex": 2,
    "explication": "`Object.assign()` copie les propriétés de un ou plusieurs objets dans un objet cible. \nExemple : \nconst a = {x:1}; \nconst b = {y:2}; \nconst c = Object.assign({}, a, b); \nconsole.log(c); // {x:1, y:2}"
  },
  {
    "question": "49 - Que permet l’opérateur spread (...) dans un tableau ?",
    "options": [
      "Effacer des éléments",
      "Fusionner des tableaux",
      "Trier un tableau",
      "Ajouter une propriété"
    ],
    "answerIndex": 1,
    "explication": "L'opérateur `...` (spread) permet d'étendre ou de fusionner des tableaux ou objets. \nExemple : \nconst a = [1,2]; const b = [3,4]; \nconst c = [...a, ...b]; \nconsole.log(c); // [1,2,3,4]"
  },
  {
    "question": "50 - À quoi sert une IIFE (Immediately Invoked Function Expression) ?",
    "options": [
      "Exécuter immédiatement une fonction et isoler son scope",
      "Créer une boucle",
      "Créer une fonction globale",
      "Créer un objet"
    ],
    "answerIndex": 0,
    "explication": "Une IIFE est une fonction immédiatement exécutée, utile pour encapsuler des variables sans polluer l’espace global. \nExemple : \n(function() { console.log('Hello'); })();"
  }
  
  
]